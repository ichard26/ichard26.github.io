<!doctype html><html lang=en-ca dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Compiling Black with mypyc, Pt. 2 - Optimization | Richard Si</title><meta name=keywords content="black,mypyc"><meta name=description content="Compiling Black without errors or warnings was the easy bit, now I had to optimize it for mypyc."><meta name=author content><link rel=canonical href=https://ichard26.github.io/blog/2022/05/compiling-black-with-mypyc-part-2/><link crossorigin=anonymous href=/assets/css/stylesheet.674a4e1d7f4d49be367e8d6a2c36157f4d7872f92e6a0e2fbfe3873cb0768a55.css integrity="sha256-Z0pOHX9NSb42fo1qLDYVf014cvkuag4vv+OHPLB2ilU=" rel="preload stylesheet" as=style><link rel=icon href=https://ichard26.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ichard26.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ichard26.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ichard26.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ichard26.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer data-domain=ichard26.github.io src=https://webstats.internal.floralily.dev/js/script.outbound-links.js></script><meta name=google-site-verification content="4PNzC3Db8jI_wn9D8lPdAh4B0skrLZHNbQBgVF1XtAo"><meta property="og:title" content="Compiling Black with mypyc, Pt. 2 - Optimization"><meta property="og:description" content="Compiling Black without errors or warnings was the easy bit, now I had to optimize it for mypyc."><meta property="og:type" content="article"><meta property="og:url" content="https://ichard26.github.io/blog/2022/05/compiling-black-with-mypyc-part-2/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-05-31T16:26:00-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Compiling Black with mypyc, Pt. 2 - Optimization"><meta name=twitter:description content="Compiling Black without errors or warnings was the easy bit, now I had to optimize it for mypyc."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://ichard26.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Compiling Black with mypyc, Pt. 2 - Optimization","item":"https://ichard26.github.io/blog/2022/05/compiling-black-with-mypyc-part-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Compiling Black with mypyc, Pt. 2 - Optimization","name":"Compiling Black with mypyc, Pt. 2 - Optimization","description":"Compiling Black without errors or warnings was the easy bit, now I had to optimize it for mypyc.","keywords":["black","mypyc"],"articleBody":"This is part of the ‚ÄúCompiling Black with mypyc‚Äù series.\nPt. 1 - Initial Steps Pt. 2 - Optimization (you‚Äôre reading this one) Pt. 3 - Deployment Optimizing for mypyc Having compiled Black successfully without it blowing up, it was time to try to optimize Black for mypyc. While mypyc is designed to handle all sorts of statically typed code, changing up the code even a little bit can allow mypyc to perform additional optimizations, ultimately helping performance a bunch.\nAnd while I did go into this hoping I could spot some potential architectural or data structure optimizations, I wasn‚Äôt able to so the optimizations shared will be mypyc specific.\nGetting started First off, profiling! It‚Äôs hard to optimize code well if you don‚Äôt know where time is being spent.\nTo start off, I profiled Black over some of its own source code with cProfile to get a birds eye view:\n$ python -m cProfile -o profile.pstats -m black src/black/__init__.py --check All done! ‚ú® üç∞ ‚ú® 1 file would be left unchanged. $ gprof2dot profile.pstats | dot -Tsvg -o profile.svg With the help of gprof2dot (well, actually the yelp-gprof2dot fork), I converted the profiling data into a nice SVG graph which I could then open in my web browser.\nTip: please open this massive SVG in a new tab because viewing it here will probably be painful :)\nI tried using Scalene as I‚Äôve heard good things about it, but it didn‚Äôt work sadly. It wasn‚Äôt that bad as I still had py-spy, line_profiler, and good ol‚Äô cProfile. py-spy in particular was invaluable since it can profile (well err sample) C extensions which cProfile cannot. line_profiler was used exclusively for micro-optimizations :p\nAnyway, I repeated this process quite a few times, making sure to try different files to get a general feel where time is going regardless of the input. Here are the main takeaways:\nInitial parsing with blib2to3 takes up 30-50% of formatting runtime!\nThe AST equivalent safety check is cheap at 5-10% (obviously only when changes were made, otherwise it‚Äôs zero üôÇ)\nThe actual formatting logic‚Äôs runtime is mostly spent in the CST visitor usually taking up 75%. The rest went to the transformers which handle line breaks, string literals, and some special cases.\nI was quite surprised how much time blib2to3 related functions were eating up. Just look how concentrated the hotspots really are!\nThese hotspots make this part of the codebase way easier to optimize, so I optimized blib2to3 first.\nIt‚Äôs been so long since I first looked into this, so I don‚Äôt remember what optimizations I tried initially, but I do remember them having no effect :(\nI tried other things and they actually helped üéâ ‚Ä¶ probably since I took into account how mypyc works. Ultimately, many different optimizations were done over three rounds.\nTightening up existing type annotations The stricter the type annotations are in your codebase, the more invariants mypyc will be able to infer. It‚Äôll then use this information to write type-specific code that is faster. This code won‚Äôt work if it gets an object of a different type, but that‚Äôs why we use and enforce type annotations, so mypyc can safely assume it‚Äôs going to be the right type. In essence, the stricter the type annotations, the faster code mypyc can generate.\nThis meant reading through the code‚Äôs control flow, checking whether certain states are impossible. Blib2to3 is a legacy codebase, so type annotations were added to unblock other work. The goal was to make blib2to3 type check, and not write perfectly typed code. So naturally, there were a few permissive (parameter) type annotations I could make stricter:\ndiff --git a/src/blib2to3/pgen2/parse.py b/src/blib2to3/pgen2/parse.py index 47c8f02..6b03188 100644 --- a/src/blib2to3/pgen2/parse.py +++ b/src/blib2to3/pgen2/parse.py @@ -138,7 +138,7 @@ class Parser(object): self.rootnode: Optional[NL] = None self.used_names: Set[str] = set() - def addtoken(self, type: int, value: Optional[Text], context: Context) -\u003e bool: + def addtoken(self, type: int, value: Text, context: Context) -\u003e bool: \"\"\"Add a token; return True iff this is the end of the program.\"\"\" # Map from token to label ilabel = self.classify(type, value, context) @@ -185,11 +185,10 @@ class Parser(object): # No success finding a transition raise ParseError(\"bad input\", type, value, context) - def classify(self, type: int, value: Optional[Text], context: Context) -\u003e int: + def classify(self, type: int, value: Text, context: Context) -\u003e int: \"\"\"Turn a token into a label. (Internal)\"\"\" if type == token.NAME: # Keep a listing of all used names - assert value is not None self.used_names.add(value) # Check for reserved words ilabel = self.grammar.keywords.get(value) @@ -201,12 +200,10 @@ class Parser(object): return ilabel def shift( - self, type: int, value: Optional[Text], newstate: int, context: Context + self, type: int, value: Text, newstate: int, context: Context ) -\u003e None: \"\"\"Shift a token. (Internal)\"\"\" dfa, state, node = self.stack[-1] - assert value is not None - assert context is not None rawnode: RawNode = (type, value, context, None) newnode = self.convert(self.grammar, rawnode) if newnode is not None: Since mypyc injects runtime type checks, simplifying Optional[Text] to Text reduces function call overhead. value only needs to pass (in equivalent C code) isinstance(value, str). This also has the neat side-effect of allowing me to remove some asserts.\nTightening up type annotations involving typing.Any can be particularly worthwhile as it forces the use of generic C code that can handle any kind of object. I could only make this change once, but it‚Äôs better than nothing.\n@@ -54,14 +56,14 @@ class Driver(object): self.logger = logger self.convert = convert - def parse_tokens(self, tokens: Iterable[Any], debug: bool = False) -\u003e NL: + def parse_tokens(self, tokens: Iterable[GoodTokenInfo], debug: bool = False) -\u003e NL: \"\"\"Parse a series of tokens and return the syntax tree.\"\"\" # XXX Move the prefix computation into a wrapper around tokenize. p = parse.Parser(self.grammar, self.convert) p.setup() lineno = 1 column = 0 Marking everything Final Avoiding calculating the same value over and over again is one of the most common optimizations out there, and it‚Äôs for good reason, it‚Äôs usually easy to fix. BUT, with mypyc we can take this further by using typing.Final. Final variables can often be injected at lookup sites at compile time, skipping the lookups at runtime!\nLet me show an example, let‚Äôs take this code and see what adding a single Final does.\nSCALE = 5 def calculate_y(x): return x * SCALE Compiling it with mypyc, the C code for the calculate_y function is .. well .. quite long! Notice how much work has to be done to safely look up the global value at runtime.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 PyObject *CPyDef_calculate_y(PyObject *cpy_r_x) { PyObject *cpy_r_r0; PyObject *cpy_r_r1; PyObject *cpy_r_r2; CPyTagged cpy_r_r3; PyObject *cpy_r_r4; PyObject *cpy_r_r5; PyObject *cpy_r_r6; CPyL0: ; cpy_r_r0 = CPyStatic_globals; cpy_r_r1 = CPyStatics[3]; /* 'SCALE' */ cpy_r_r2 = CPyDict_GetItem(cpy_r_r0, cpy_r_r1); if (unlikely(cpy_r_r2 == NULL)) { CPy_AddTraceback(\"final.py\", \"calculate_y\", 6, CPyStatic_globals); goto CPyL4; } CPyL1: ; if (likely(PyLong_Check(cpy_r_r2))) cpy_r_r3 = CPyTagged_FromObject(cpy_r_r2); else { CPy_TypeError(\"int\", cpy_r_r2); cpy_r_r3 = CPY_INT_TAG; } CPy_DECREF(cpy_r_r2); if (unlikely(cpy_r_r3 == CPY_INT_TAG)) { CPy_AddTraceback(\"final.py\", \"calculate_y\", 6, CPyStatic_globals); goto CPyL4; } CPyL2: ; cpy_r_r4 = CPyTagged_StealAsObject(cpy_r_r3); cpy_r_r5 = PyNumber_Multiply(cpy_r_x, cpy_r_r4); CPy_DECREF(cpy_r_r4); if (unlikely(cpy_r_r5 == NULL)) { CPy_AddTraceback(\"final.py\", \"calculate_y\", 6, CPyStatic_globals); goto CPyL4; } CPyL3: ; return cpy_r_r5; CPyL4: ; cpy_r_r6 = NULL; return cpy_r_r6; } If we mark the SCALE variable as Final, mypyc will notice that and inline the value.\nfrom typing import Final SCALE: Final = 5 def calculate_y(x): return x * SCALE Just look at how much shorter this is!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 PyObject *CPyDef_calculate_y(PyObject *cpy_r_x) { PyObject *cpy_r_r0; PyObject *cpy_r_r1; PyObject *cpy_r_r2; CPyL0: ; cpy_r_r0 = CPyTagged_StealAsObject(10); cpy_r_r1 = PyNumber_Multiply(cpy_r_x, cpy_r_r0); CPy_DECREF(cpy_r_r0); if (unlikely(cpy_r_r1 == NULL)) { CPy_AddTraceback(\"final.py\", \"calculate_y\", 6, CPyStatic_globals); goto CPyL2; } CPyL1: ; return cpy_r_r1; CPyL2: ; cpy_r_r2 = NULL; return cpy_r_r2; } If the value can‚Äôt be inlined, say because it involves a function call then mypyc will just replace the globals dictionary lookup and instead use a C static (which is still faster).\nApplying this optimization to Black yields changes like the following to black.comments and black.parsing1 respectively:\n@@ -12,11 +18,10 @@ from black.nodes import STANDALONE_COMMENT, WHITESPACE # types LN = Union[Leaf, Node] - -FMT_OFF = {\"# fmt: off\", \"# fmt:off\", \"# yapf: disable\"} -FMT_SKIP = {\"# fmt: skip\", \"# fmt:skip\"} -FMT_PASS = {*FMT_OFF, *FMT_SKIP} -FMT_ON = {\"# fmt: on\", \"# fmt:on\", \"# yapf: enable\"} +FMT_OFF: Final = {\"# fmt: off\", \"# fmt:off\", \"# yapf: disable\"} +FMT_SKIP: Final = {\"# fmt: skip\", \"# fmt:skip\"} +FMT_PASS: Final = {*FMT_OFF, *FMT_SKIP} +FMT_ON: Final = {\"# fmt: on\", \"# fmt:on\", \"# yapf: enable\"} @dataclass @@ -36,6 +36,11 @@ except ImportError: else: ast3 = ast27 = ast +if sys.version_info \u003e= (3, 8): + TYPE_IGNORE_CLASSES: Final = (ast3.TypeIgnore, ast27.TypeIgnore, ast.TypeIgnore) +else: + TYPE_IGNORE_CLASSES: Final = (ast3.TypeIgnore, ast27.TypeIgnore) + class InvalidInput(ValueError): \"\"\"Raised when input source code fails all parse attempts.\"\"\" @@ -160,10 +165,7 @@ def stringify_ast( for field in sorted(node._fields): # noqa: F402 # TypeIgnore has only one field 'lineno' which breaks this comparison - type_ignore_classes: Tuple[Type, ...] = (ast3.TypeIgnore, ast27.TypeIgnore) - if sys.version_info \u003e= (3, 8): - type_ignore_classes += (ast.TypeIgnore,) - if isinstance(node, type_ignore_classes): + if isinstance(node, TYPE_IGNORE_CLASSES): break try: In total, this was the most common optimization I applied throughout this whole project. It‚Äôs simple but effective!\nTaking advantage of early binding Final is so fast because of early binding. What‚Äôs great is you can take advantage of early binding with function calls too, assuming your code is static enough.\nTime for another example:\nfrom typing import Callable, List def tag(item: object) -\u003e str: return \"\" + repr(item) def process_items(func: Callable[[object], object], items: List[object]) -\u003e List[object]: return [func(i) for i in items] process_items(tag, [\"1\", \"2\", \"3\"]) The function used to process the items isn‚Äôt known until call time, forcing mypyc to fall back to the standard Python calling convention (albeit it does use the faster vectorcall convention available for C functions). If I instead hardcode tag in process_items, mypyc can call the C function directly which involves way less work.\nfrom typing import List def tag(item: object) -\u003e str: return \"\" + repr(item) def process_items(List[object]) -\u003e List[object]: return [tag(i) for i in items] process_items([\"1\", \"2\", \"3\"]) CPyL3: ; cpy_r_r8 = CPyList_GetItemUnsafe(cpy_r_items, cpy_r_r3); cpy_r_i = cpy_r_r8; - PyObject *cpy_r_r9[1] = {cpy_r_i}; - cpy_r_r10 = (PyObject **)\u0026cpy_r_r9; - cpy_r_r11 = _PyObject_Vectorcall(cpy_r_func, cpy_r_r10, 1, 0); - if (unlikely(cpy_r_r11 == NULL)) { + cpy_r_r9 = CPyDef_convert(cpy_r_i); + CPy_DECREF(cpy_r_i); + if (unlikely(cpy_r_r9 == NULL)) { CPy_AddTraceback(\"early_binding.py\", \"process_items\", 7, CPyStatic_globals); goto CPyL8; } Most of the time this isn‚Äôt possible because if your function calls are dynamic, it‚Äôs probably because the code depends on it ‚Ä¶ but keep it in mind.\nBy sheer luck, I was able to replace two dynamic function calls with static calls in blib2to3.pgen2.parse.Parser, the very hot parser code!\ndiff --git a/src/blib2to3/pgen2/parse.py b/src/blib2to3/pgen2/parse.py index 6b03188..b5da4fa 100644 --- a/src/blib2to3/pgen2/parse.py +++ b/src/blib2to3/pgen2/parse.py @@ -23,7 +23,7 @@ from typing import ( Set, ) from blib2to3.pgen2.grammar import Grammar -from blib2to3.pytree import NL, Context, RawNode, Leaf, Node +from blib2to3.pytree import convert, NL, Context, RawNode, Leaf, Node @@ -199,16 +206,13 @@ class Parser(object): raise ParseError(\"bad token\", type, value, context) return ilabel def shift(self, type: int, value: Text, newstate: int, context: Context) -\u003e None: \"\"\"Shift a token. (Internal)\"\"\" dfa, state, node = self.stack[-1] rawnode: RawNode = (type, value, context, None) - newnode = self.convert(self.grammar, rawnode) - if newnode is not None: - assert node[-1] is not None - node[-1].append(newnode) + newnode = convert(self.grammar, rawnode) + assert node[-1] is not None + node[-1].append(newnode) self.stack[-1] = (dfa, newstate, node) def push(self, type: int, newdfa: DFAS, newstate: int, context: Context) -\u003e None: @@ -221,12 +225,11 @@ class Parser(object): def pop(self) -\u003e None: \"\"\"Pop a nonterminal. (Internal)\"\"\" popdfa, popstate, popnode = self.stack.pop() - newnode = self.convert(self.grammar, popnode) - if newnode is not None: - if self.stack: - dfa, state, node = self.stack[-1] - assert node[-1] is not None - node[-1].append(newnode) - else: - self.rootnode = newnode - self.rootnode.used_names = self.used_names + newnode = convert(self.grammar, popnode) + if self.stack: + dfa, state, node = self.stack[-1] + assert node[-1] is not None + node[-1].append(newnode) + else: + self.rootnode = newnode + self.rootnode.used_names = self.used_names Also since blib2to3.pytree.convert is guaranteed to return a non-None value, I could drop a branch which was neat :)\nDetour: let‚Äôs build developer tooling! If you‚Äôve worked with me before you‚Äôll know that I love to write developer tooling to make life easier. (Un)fortunately this project needed two bits of tooling that simply didn‚Äôt exist at the time:\nA benchmark suite A tool to compare two builds of Black behaviourally The first one is pretty self-explanatory, I needed a good benchmark suite to make sure this project would actually improve performance, and to also quantify the gains (important when weighing optimizations).\nThe second one is less clear, I effectively wanted mypy-primer, but for Black:\nmypy-primer comment on mypy PR #12064.\nSo I got to work creating blackbench and (the original) diff-shades. In hindsight, blackbench sucks and needs a rewrite so I don‚Äôt want to go into too much detail about it, but the summary is that it came with benchmarks for the following tasks:\nFormatting with safety checks Formatting without safety checks Blib2to3 parsing across quite a few inputs. The story is similar for the original diff-shades, it worked and made it possible to verify mypyc didn‚Äôt change formatting, but its code was horrible (and not to mention unmaintainable). It was bad enough that I rewrote the tool later on.\nThe TL;DR version of what diff-shades does is that it clones a bunch of projects, runs Black on ‚Äôem while recording the results. Then you use its other commands to analyze and compare recordings.\nDetour: does GCC help? At this point I had found a workaround to the GCC array subscript 1 is above array bounds error and was curious to whether using GCC would produce faster binaries. The answer turned out to be very much no.\nAnyway, other than getting distracted by diff-shades, I looked into the gcc issue to find a potential workaround. I found one, but it was useless üôÇ Collecting numbers for both gcc-10 and clang showed that gcc fails in basically all departments:\ntakes almost twice as long to compile Black AND definitely uses 200%+ more memory had no meaningful difference in generated binary size all while being far more picky about the C code it‚Äôs given oh and of course produced binaries that were around 8% slower üôÉ I‚Äôm honestly happy that GCC failed to compile on that parser setup code, clang (for Linux) is so much better.\nResults Quick note\nI also did some micro-optimizations like reordering if checks to hit the common case first or replacing x = x + 1 with x += 1, but to this day I don‚Äôt know whether they actually had an impact.\nAdditionally, I haven‚Äôt discussed the last optimization round I did for src/black, but there‚Äôs nothing in that which I haven‚Äôt covered yet.\nAnyhow, these optimizations bumped the parsing speedup over interpreted from ~1.73x to ~1.9x. You can see the changes made here and also here.\nFor more detail, see the tables at the bottom for the compiled-mypyc-preopt and compiled-mypyc columns in this report I compiled. It took a long time to compile this report by the way, setting up a properly configured benchmark setup and gathering multiple data samples is very time consuming!\nIn the end, I managed to increase compiled performance by an additional 10-15% which is pretty nice! I was aiming for 25%, but in hindsight I might have been hoping for too much üôÇ. Also yes, they were virtually useless when interpreted.\nWe‚Äôre nearly there, only Pt. 3 - Deployment remains. It‚Äôs shorter, believe me.\nIn the end, I had to revert this optimization so Black wouldn‚Äôt crash under PyPy, can‚Äôt remember what the error was though¬†‚Ü©Ô∏é\n","wordCount":"2662","inLanguage":"en-ca","datePublished":"2022-05-31T16:26:00-04:00","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ichard26.github.io/blog/2022/05/compiling-black-with-mypyc-part-2/"},"publisher":{"@type":"Person","name":"Richard Si","logo":{"@type":"ImageObject","url":"https://ichard26.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ichard26.github.io/ accesskey=h title="Richard Si (Alt + H)">Richard Si</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ichard26.github.io/about/ title=About><span>about</span></a></li><li><a href=https://ichard26.github.io/blog/ title=Writing><span>writing</span></a></li><li><a href=https://ichard26.github.io/privacy/ title="Privacy Statement"><span>privacy</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Compiling Black with mypyc, Pt. 2 - Optimization</h1><div class=post-description>Compiling Black without errors or warnings was the easy bit, now I had to optimize it for mypyc.</div><div class=post-meta><span class=post-date title='Posted on 2022-05-31 16:26:00 -0400 -0400'>May 31, 2022</span><span class=delimiter>&nbsp;¬∑&nbsp;</span>13 minutes</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#optimizing-for-mypyc aria-label="Optimizing for mypyc">Optimizing for mypyc</a><ul><li><a href=#getting-started aria-label="Getting started">Getting started</a><ul><li><a href=#tightening-up-existing-type-annotations aria-label="Tightening up existing type annotations">Tightening up existing type annotations</a></li><li><a href=#marking-everything-final aria-label="Marking everything Final">Marking everything Final</a></li><li><a href=#taking-advantage-of-early-binding aria-label="Taking advantage of early binding">Taking advantage of early binding</a></li></ul></li><li><a href=#detour-lets-build-developer-tooling aria-label="Detour: let&rsquo;s build developer tooling!">Detour: let&rsquo;s build developer tooling!</a></li><li><a href=#detour-does-gcc-help aria-label="Detour: does GCC help?">Detour: does GCC help?</a></li><li><a href=#results aria-label=Results>Results</a></li></ul></li></ul></div></details></div><div class=post-content><p>This is part of the &ldquo;<em>Compiling Black with mypyc</em>&rdquo; series.</p><ul><li><a href=../compiling-black-with-mypyc-part-1/>Pt. 1 - Initial Steps</a></li><li><a href=.>Pt. 2 - Optimization</a> (you&rsquo;re reading this one)</li><li><a href=../compiling-black-with-mypyc-part-3/>Pt. 3 - Deployment</a></li></ul><h2 id=optimizing-for-mypyc>Optimizing for mypyc<a hidden class=anchor aria-hidden=true href=#optimizing-for-mypyc>#</a></h2><p>Having compiled Black successfully without it blowing up, it was time to try to optimize
Black for mypyc. While mypyc is designed to handle all sorts of statically typed code,
<strong>changing up the code even a little bit can allow mypyc to perform additional
optimizations</strong>, ultimately helping performance a bunch.</p><p>And while I did go into this hoping I could spot some potential architectural or data
structure optimizations, I wasn&rsquo;t able to so the optimizations shared will be mypyc
specific.</p><h3 id=getting-started>Getting started<a hidden class=anchor aria-hidden=true href=#getting-started>#</a></h3><p>First off, profiling! It&rsquo;s hard to optimize code well if you don&rsquo;t know where time is
being spent.</p><p>To start off, I profiled Black over some of its own source code with cProfile to get a
birds eye view:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ python -m cProfile -o profile.pstats -m black src/black/__init__.py --check
</span></span><span style=display:flex><span>All done! ‚ú® üç∞ ‚ú®
</span></span><span style=display:flex><span>1 file would be left unchanged.
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>$ gprof2dot profile.pstats | dot -Tsvg -o profile.svg
</span></span></code></pre></div><p>With the help of <a href=https://github.com/jrfonseca/gprof2dot target=_blank>gprof2dot</a> (well, actually the <a href=https://pypi.org/project/yelp-gprof2dot/ target=_blank>yelp-gprof2dot</a> fork), I converted the
profiling data into a nice SVG graph which I could then open in my web browser.</p><blockquote><p>Tip: please open this massive SVG in a new tab because viewing it here will probably be
painful :)</p></blockquote><p><img loading=lazy src=/media/cProfileGraph-black-1.svg alt="gprof2dot graph showing where time was spent in a call tree"></p><p>I tried using <a href=https://pypi.org/project/scalene/ target=_blank>Scalene</a> as I&rsquo;ve heard good things about it, but it didn&rsquo;t work sadly. It
wasn&rsquo;t that bad as I still had <a href=https://github.com/benfred/py-spy target=_blank>py-spy</a>, <a href=https://pypi.org/project/line-profiler/ target=_blank>line_profiler</a>, and good ol&rsquo; cProfile. py-spy in
particular was invaluable since it can profile (well err sample) C extensions which
cProfile cannot. line_profiler was used exclusively for micro-optimizations :p</p><p>Anyway, I repeated this process quite a few times, making sure to try different files to
get a general feel where time is going regardless of the input. Here are the main
takeaways:</p><ul><li><p>Initial parsing with blib2to3 takes up 30-50% of formatting runtime!</p></li><li><p>The AST equivalent safety check is cheap at 5-10% (obviously only when changes were
made, otherwise it&rsquo;s zero üôÇ)</p></li><li><p>The actual formatting logic&rsquo;s runtime is mostly spent in the CST visitor usually taking
up 75%. The rest went to the transformers which handle line breaks, string literals, and
some special cases.</p></li></ul><p>I was quite surprised how much time blib2to3 related functions were eating up. Just look
how concentrated the hotspots really are!</p><p><img loading=lazy src=/media/cProfileGraph-black-blib2to3-1.svg alt="gprof2dot graph showing where time was spent parsing"></p><p>These hotspots make this part of the codebase way easier to optimize, so I optimized
blib2to3 first.</p><p>It&rsquo;s been so long since I first looked into this, so I don&rsquo;t remember what optimizations I
tried initially, but I do remember them having no effect :(</p><p>I tried other things and they actually helped üéâ &mldr; probably since I took into account how
mypyc works. Ultimately, many different optimizations were done over three rounds.</p><h4 id=tightening-up-existing-type-annotations>Tightening up existing type annotations<a hidden class=anchor aria-hidden=true href=#tightening-up-existing-type-annotations>#</a></h4><p>The stricter the type annotations are in your codebase, the more invariants mypyc will be
able to infer. It&rsquo;ll then use this information to write type-specific code that is faster.
This code won&rsquo;t work if it gets an object of a different type, but that&rsquo;s why we use and
enforce type annotations, so mypyc can safely assume it&rsquo;s going to be the right type. <strong>In
essence, the stricter the type annotations, the faster code mypyc can generate.</strong></p><p>This meant reading through the code&rsquo;s control flow, checking whether certain states are
impossible. Blib2to3 is a legacy codebase, so type annotations were added to unblock other
work. The goal was to make blib2to3 type check, and not write perfectly typed code. So
naturally, there were a few permissive (parameter) type annotations I could make stricter:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff --git a/src/blib2to3/pgen2/parse.py b/src/blib2to3/pgen2/parse.py
</span></span><span style=display:flex><span>index 47c8f02..6b03188 100644
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/src/blib2to3/pgen2/parse.py
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/src/blib2to3/pgen2/parse.py
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -138,7 +138,7 @@ class Parser(object):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         self.rootnode: Optional[NL] = None
</span></span><span style=display:flex><span>         self.used_names: Set[str] = set()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>-    def addtoken(self, type: int, value: Optional[Text], context: Context) -&gt; bool:
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+    def addtoken(self, type: int, value: Text, context: Context) -&gt; bool:
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>         &#34;&#34;&#34;Add a token; return True iff this is the end of the program.&#34;&#34;&#34;
</span></span><span style=display:flex><span>         # Map from token to label
</span></span><span style=display:flex><span>         ilabel = self.classify(type, value, context)
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -185,11 +185,10 @@ class Parser(object):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                     # No success finding a transition
</span></span><span style=display:flex><span>                     raise ParseError(&#34;bad input&#34;, type, value, context)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>-    def classify(self, type: int, value: Optional[Text], context: Context) -&gt; int:
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+    def classify(self, type: int, value: Text, context: Context) -&gt; int:
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>         &#34;&#34;&#34;Turn a token into a label.  (Internal)&#34;&#34;&#34;
</span></span><span style=display:flex><span>         if type == token.NAME:
</span></span><span style=display:flex><span>             # Keep a listing of all used names
</span></span><span style=display:flex><span><span style=color:#f92672>-            assert value is not None
</span></span></span><span style=display:flex><span><span style=color:#f92672></span>             self.used_names.add(value)
</span></span><span style=display:flex><span>             # Check for reserved words
</span></span><span style=display:flex><span>             ilabel = self.grammar.keywords.get(value)
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -201,12 +200,10 @@ class Parser(object):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         return ilabel
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     def shift(
</span></span><span style=display:flex><span><span style=color:#f92672>-        self, type: int, value: Optional[Text], newstate: int, context: Context
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+        self, type: int, value: Text, newstate: int, context: Context
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>     ) -&gt; None:
</span></span><span style=display:flex><span>         &#34;&#34;&#34;Shift a token.  (Internal)&#34;&#34;&#34;
</span></span><span style=display:flex><span>         dfa, state, node = self.stack[-1]
</span></span><span style=display:flex><span><span style=color:#f92672>-        assert value is not None
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        assert context is not None
</span></span></span><span style=display:flex><span><span style=color:#f92672></span>         rawnode: RawNode = (type, value, context, None)
</span></span><span style=display:flex><span>         newnode = self.convert(self.grammar, rawnode)
</span></span><span style=display:flex><span>         if newnode is not None:
</span></span></code></pre></div><p>Since mypyc injects runtime type checks, simplifying <code>Optional[Text]</code> to <code>Text</code> reduces
function call overhead. <code>value</code> only needs to pass (in equivalent C code)
<code>isinstance(value, str)</code>. This also has the neat side-effect of allowing me to remove some
asserts.</p><p>Tightening up type annotations involving <a href=https://docs.python.org/3/library/typing.html#typing.Any target=_blank><code>typing.Any</code></a> can be particularly
worthwhile as it forces the use of generic C code that can handle any kind of object. I
could only make this change once, but it&rsquo;s better than nothing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#75715e>@@ -54,14 +56,14 @@ class Driver(object):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         self.logger = logger
</span></span><span style=display:flex><span>         self.convert = convert
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>-    def parse_tokens(self, tokens: Iterable[Any], debug: bool = False) -&gt; NL:
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+    def parse_tokens(self, tokens: Iterable[GoodTokenInfo], debug: bool = False) -&gt; NL:
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>         &#34;&#34;&#34;Parse a series of tokens and return the syntax tree.&#34;&#34;&#34;
</span></span><span style=display:flex><span>         # XXX Move the prefix computation into a wrapper around tokenize.
</span></span><span style=display:flex><span>         p = parse.Parser(self.grammar, self.convert)
</span></span><span style=display:flex><span>         p.setup()
</span></span><span style=display:flex><span>         lineno = 1
</span></span><span style=display:flex><span>         column = 0
</span></span></code></pre></div><h4 id=marking-everything-final>Marking everything Final<a hidden class=anchor aria-hidden=true href=#marking-everything-final>#</a></h4><p>Avoiding calculating the same value over and over again is one of the most common
optimizations out there, and it&rsquo;s for good reason, it&rsquo;s usually easy to fix. BUT, with
mypyc we can take this further by using <a href=https://docs.python.org/3/library/typing.html#typing.Final target=_blank><code>typing.Final</code></a>. Final variables
can often be injected at lookup sites at compile time, skipping the lookups at runtime!</p><p>Let me show an example, let&rsquo;s take this code and see what adding a single <code>Final</code> does.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span>SCALE <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calculate_y</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>*</span> SCALE
</span></span></code></pre></div><p>Compiling it with mypyc, the C code for the <code>calculate_y</code> function is .. well .. quite
long! Notice how much work has to be done to safely look up the global value at runtime.</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span></span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span></span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-c data-lang=c><span style=display:flex><span>PyObject <span style=color:#f92672>*</span><span style=color:#a6e22e>CPyDef_calculate_y</span>(PyObject <span style=color:#f92672>*</span>cpy_r_x) {
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>cpy_r_r0;
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>cpy_r_r1;
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>cpy_r_r2;
</span></span><span style=display:flex><span>    CPyTagged cpy_r_r3;
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>cpy_r_r4;
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>cpy_r_r5;
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>cpy_r_r6;
</span></span><span style=display:flex><span>CPyL0: ;
</span></span><span style=display:flex;background-color:#3c3d38><span>    cpy_r_r0 <span style=color:#f92672>=</span> CPyStatic_globals;
</span></span><span style=display:flex;background-color:#3c3d38><span>    cpy_r_r1 <span style=color:#f92672>=</span> CPyStatics[<span style=color:#ae81ff>3</span>]; <span style=color:#75715e>/* &#39;SCALE&#39; */</span>
</span></span><span style=display:flex;background-color:#3c3d38><span>    cpy_r_r2 <span style=color:#f92672>=</span> <span style=color:#a6e22e>CPyDict_GetItem</span>(cpy_r_r0, cpy_r_r1);
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(cpy_r_r2 <span style=color:#f92672>==</span> NULL)) {
</span></span><span style=display:flex;background-color:#3c3d38><span>        <span style=color:#a6e22e>CPy_AddTraceback</span>(<span style=color:#e6db74>&#34;final.py&#34;</span>, <span style=color:#e6db74>&#34;calculate_y&#34;</span>, <span style=color:#ae81ff>6</span>, CPyStatic_globals);
</span></span><span style=display:flex;background-color:#3c3d38><span>        <span style=color:#66d9ef>goto</span> CPyL4;
</span></span><span style=display:flex;background-color:#3c3d38><span>    }
</span></span><span style=display:flex;background-color:#3c3d38><span>CPyL1: ;
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>likely</span>(<span style=color:#a6e22e>PyLong_Check</span>(cpy_r_r2)))
</span></span><span style=display:flex;background-color:#3c3d38><span>        cpy_r_r3 <span style=color:#f92672>=</span> <span style=color:#a6e22e>CPyTagged_FromObject</span>(cpy_r_r2);
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex;background-color:#3c3d38><span>        <span style=color:#a6e22e>CPy_TypeError</span>(<span style=color:#e6db74>&#34;int&#34;</span>, cpy_r_r2); cpy_r_r3 <span style=color:#f92672>=</span> CPY_INT_TAG;
</span></span><span style=display:flex;background-color:#3c3d38><span>    }
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#a6e22e>CPy_DECREF</span>(cpy_r_r2);
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(cpy_r_r3 <span style=color:#f92672>==</span> CPY_INT_TAG)) {
</span></span><span style=display:flex;background-color:#3c3d38><span>        <span style=color:#a6e22e>CPy_AddTraceback</span>(<span style=color:#e6db74>&#34;final.py&#34;</span>, <span style=color:#e6db74>&#34;calculate_y&#34;</span>, <span style=color:#ae81ff>6</span>, CPyStatic_globals);
</span></span><span style=display:flex;background-color:#3c3d38><span>        <span style=color:#66d9ef>goto</span> CPyL4;
</span></span><span style=display:flex;background-color:#3c3d38><span>    }
</span></span><span style=display:flex><span>CPyL2: ;
</span></span><span style=display:flex><span>    cpy_r_r4 <span style=color:#f92672>=</span> <span style=color:#a6e22e>CPyTagged_StealAsObject</span>(cpy_r_r3);
</span></span><span style=display:flex><span>    cpy_r_r5 <span style=color:#f92672>=</span> <span style=color:#a6e22e>PyNumber_Multiply</span>(cpy_r_x, cpy_r_r4);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CPy_DECREF</span>(cpy_r_r4);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(cpy_r_r5 <span style=color:#f92672>==</span> NULL)) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CPy_AddTraceback</span>(<span style=color:#e6db74>&#34;final.py&#34;</span>, <span style=color:#e6db74>&#34;calculate_y&#34;</span>, <span style=color:#ae81ff>6</span>, CPyStatic_globals);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> CPyL4;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>CPyL3: ;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cpy_r_r5;
</span></span><span style=display:flex><span>CPyL4: ;
</span></span><span style=display:flex><span>    cpy_r_r6 <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cpy_r_r6;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>If we mark the <code>SCALE</code> variable as Final, <strong>mypyc will notice that and inline the value</strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> Final
</span></span><span style=display:flex><span>
</span></span><span style=display:flex;background-color:#3c3d38><span>SCALE: Final <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calculate_y</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>*</span> SCALE
</span></span></code></pre></div><p>Just look at how much shorter this is!</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style=background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span></span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-c data-lang=c><span style=display:flex><span>PyObject <span style=color:#f92672>*</span><span style=color:#a6e22e>CPyDef_calculate_y</span>(PyObject <span style=color:#f92672>*</span>cpy_r_x) {
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>cpy_r_r0;
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>cpy_r_r1;
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>cpy_r_r2;
</span></span><span style=display:flex><span>CPyL0: ;
</span></span><span style=display:flex;background-color:#3c3d38><span>    cpy_r_r0 <span style=color:#f92672>=</span> <span style=color:#a6e22e>CPyTagged_StealAsObject</span>(<span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>    cpy_r_r1 <span style=color:#f92672>=</span> <span style=color:#a6e22e>PyNumber_Multiply</span>(cpy_r_x, cpy_r_r0);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CPy_DECREF</span>(cpy_r_r0);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>unlikely</span>(cpy_r_r1 <span style=color:#f92672>==</span> NULL)) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CPy_AddTraceback</span>(<span style=color:#e6db74>&#34;final.py&#34;</span>, <span style=color:#e6db74>&#34;calculate_y&#34;</span>, <span style=color:#ae81ff>6</span>, CPyStatic_globals);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> CPyL2;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>CPyL1: ;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cpy_r_r1;
</span></span><span style=display:flex><span>CPyL2: ;
</span></span><span style=display:flex><span>    cpy_r_r2 <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cpy_r_r2;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>If the value can&rsquo;t be inlined, say because it involves a function call then mypyc will
just replace the globals dictionary lookup and instead use a C static (which is still
faster).</p><p>Applying this optimization to Black yields changes like the following to <code>black.comments</code>
and <code>black.parsing</code><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> respectively:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#75715e>@@ -12,11 +18,10 @@ from black.nodes import STANDALONE_COMMENT, WHITESPACE
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> # types
</span></span><span style=display:flex><span> LN = Union[Leaf, Node]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>-
</span></span></span><span style=display:flex><span><span style=color:#f92672>-FMT_OFF = {&#34;# fmt: off&#34;, &#34;# fmt:off&#34;, &#34;# yapf: disable&#34;}
</span></span></span><span style=display:flex><span><span style=color:#f92672>-FMT_SKIP = {&#34;# fmt: skip&#34;, &#34;# fmt:skip&#34;}
</span></span></span><span style=display:flex><span><span style=color:#f92672>-FMT_PASS = {*FMT_OFF, *FMT_SKIP}
</span></span></span><span style=display:flex><span><span style=color:#f92672>-FMT_ON = {&#34;# fmt: on&#34;, &#34;# fmt:on&#34;, &#34;# yapf: enable&#34;}
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+FMT_OFF: Final = {&#34;# fmt: off&#34;, &#34;# fmt:off&#34;, &#34;# yapf: disable&#34;}
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+FMT_SKIP: Final = {&#34;# fmt: skip&#34;, &#34;# fmt:skip&#34;}
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+FMT_PASS: Final = {*FMT_OFF, *FMT_SKIP}
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+FMT_ON: Final = {&#34;# fmt: on&#34;, &#34;# fmt:on&#34;, &#34;# yapf: enable&#34;}
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> @dataclass
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#75715e>@@ -36,6 +36,11 @@ except ImportError:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     else:
</span></span><span style=display:flex><span>         ast3 = ast27 = ast
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>+if sys.version_info &gt;= (3, 8):
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    TYPE_IGNORE_CLASSES: Final = (ast3.TypeIgnore, ast27.TypeIgnore, ast.TypeIgnore)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+else:
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    TYPE_IGNORE_CLASSES: Final = (ast3.TypeIgnore, ast27.TypeIgnore)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span> class InvalidInput(ValueError):
</span></span><span style=display:flex><span>     &#34;&#34;&#34;Raised when input source code fails all parse attempts.&#34;&#34;&#34;
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -160,10 +165,7 @@ def stringify_ast(
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>     for field in sorted(node._fields):  # noqa: F402
</span></span><span style=display:flex><span>         # TypeIgnore has only one field &#39;lineno&#39; which breaks this comparison
</span></span><span style=display:flex><span><span style=color:#f92672>-        type_ignore_classes: Tuple[Type, ...] = (ast3.TypeIgnore, ast27.TypeIgnore)
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        if sys.version_info &gt;= (3, 8):
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            type_ignore_classes += (ast.TypeIgnore,)
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        if isinstance(node, type_ignore_classes):
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+        if isinstance(node, TYPE_IGNORE_CLASSES):
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>             break
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         try:
</span></span></code></pre></div><p>In total, this was the most common optimization I applied throughout this whole project.
It&rsquo;s simple but effective!</p><h4 id=taking-advantage-of-early-binding>Taking advantage of early binding<a hidden class=anchor aria-hidden=true href=#taking-advantage-of-early-binding>#</a></h4><p><code>Final</code> is so fast because of early binding. What&rsquo;s great is you can take advantage of
early binding with function calls too, assuming your code is static enough.</p><p>Time for another example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> Callable, List
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>tag</span>(item: object) <span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&lt;tag&gt;&#34;</span> <span style=color:#f92672>+</span> repr(item)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>process_items</span>(func: Callable[[object], object], items: List[object]) <span style=color:#f92672>-&gt;</span> List[object]:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [func(i) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> items]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>process_items(tag, [<span style=color:#e6db74>&#34;1&#34;</span>, <span style=color:#e6db74>&#34;2&#34;</span>, <span style=color:#e6db74>&#34;3&#34;</span>])
</span></span></code></pre></div><p>The function used to process the items isn&rsquo;t known until call time, forcing mypyc to fall
back to the standard Python calling convention (albeit it does use the faster
<a href=https://peps.python.org/pep-0590/ target=_blank>vectorcall convention</a> available for C functions). If I instead hardcode <code>tag</code> in
<code>process_items</code>, mypyc can <strong>call the C function directly</strong> which involves way less work.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> List
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>tag</span>(item: object) <span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&lt;tag&gt;&#34;</span> <span style=color:#f92672>+</span> repr(item)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>process_items</span>(List[object]) <span style=color:#f92672>-&gt;</span> List[object]:
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#66d9ef>return</span> [tag(i) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> items]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>process_items([<span style=color:#e6db74>&#34;1&#34;</span>, <span style=color:#e6db74>&#34;2&#34;</span>, <span style=color:#e6db74>&#34;3&#34;</span>])
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-diff data-lang=diff><span style=display:flex><span> CPyL3: ;
</span></span><span style=display:flex><span>     cpy_r_r8 = CPyList_GetItemUnsafe(cpy_r_items, cpy_r_r3);
</span></span><span style=display:flex><span>     cpy_r_i = cpy_r_r8;
</span></span><span style=display:flex><span><span style=color:#f92672>-    PyObject *cpy_r_r9[1] = {cpy_r_i};
</span></span></span><span style=display:flex><span><span style=color:#f92672>-    cpy_r_r10 = (PyObject **)&amp;cpy_r_r9;
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#f92672>-    cpy_r_r11 = _PyObject_Vectorcall(cpy_r_func, cpy_r_r10, 1, 0);
</span></span></span><span style=display:flex><span><span style=color:#f92672>-    if (unlikely(cpy_r_r11 == NULL)) {
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#f92672></span><span style=color:#a6e22e>+    cpy_r_r9 = CPyDef_convert(cpy_r_i);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    CPy_DECREF(cpy_r_i);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    if (unlikely(cpy_r_r9 == NULL)) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>         CPy_AddTraceback(&#34;early_binding.py&#34;, &#34;process_items&#34;, 7, CPyStatic_globals);
</span></span><span style=display:flex><span>         goto CPyL8;
</span></span><span style=display:flex><span>     }
</span></span></code></pre></div><p>Most of the time this isn&rsquo;t possible because if your function calls are dynamic, it&rsquo;s
probably because the code depends on it &mldr; but keep it in mind.</p><p>By sheer luck, I was able to replace two dynamic function calls with static calls in
<code>blib2to3.pgen2.parse.Parser</code>, the very hot parser code!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-diff data-lang=diff><span style=display:flex><span>diff --git a/src/blib2to3/pgen2/parse.py b/src/blib2to3/pgen2/parse.py
</span></span><span style=display:flex><span>index 6b03188..b5da4fa 100644
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/src/blib2to3/pgen2/parse.py
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/src/blib2to3/pgen2/parse.py
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -23,7 +23,7 @@ from typing import (
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     Set,
</span></span><span style=display:flex><span> )
</span></span><span style=display:flex><span> from blib2to3.pgen2.grammar import Grammar
</span></span><span style=display:flex><span><span style=color:#f92672>-from blib2to3.pytree import NL, Context, RawNode, Leaf, Node
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+from blib2to3.pytree import convert, NL, Context, RawNode, Leaf, Node
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>@@ -199,16 +206,13 @@ class Parser(object):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             raise ParseError(&#34;bad token&#34;, type, value, context)
</span></span><span style=display:flex><span>         return ilabel
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     def shift(self, type: int, value: Text, newstate: int, context: Context) -&gt; None:
</span></span><span style=display:flex><span>         &#34;&#34;&#34;Shift a token.  (Internal)&#34;&#34;&#34;
</span></span><span style=display:flex><span>         dfa, state, node = self.stack[-1]
</span></span><span style=display:flex><span>         rawnode: RawNode = (type, value, context, None)
</span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#f92672>-        newnode = self.convert(self.grammar, rawnode)
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        if newnode is not None:
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            assert node[-1] is not None
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            node[-1].append(newnode)
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#f92672></span><span style=color:#a6e22e>+        newnode = convert(self.grammar, rawnode)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        assert node[-1] is not None
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        node[-1].append(newnode)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>         self.stack[-1] = (dfa, newstate, node)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     def push(self, type: int, newdfa: DFAS, newstate: int, context: Context) -&gt; None:
</span></span><span style=display:flex><span>     @@ -221,12 +225,11 @@ class Parser(object):
</span></span><span style=display:flex><span>     def pop(self) -&gt; None:
</span></span><span style=display:flex><span>         &#34;&#34;&#34;Pop a nonterminal.  (Internal)&#34;&#34;&#34;
</span></span><span style=display:flex><span>         popdfa, popstate, popnode = self.stack.pop()
</span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#f92672>-        newnode = self.convert(self.grammar, popnode)
</span></span></span><span style=display:flex><span><span style=color:#f92672>-        if newnode is not None:
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            if self.stack:
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                dfa, state, node = self.stack[-1]
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                assert node[-1] is not None
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                node[-1].append(newnode)
</span></span></span><span style=display:flex><span><span style=color:#f92672>-            else:
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                self.rootnode = newnode
</span></span></span><span style=display:flex><span><span style=color:#f92672>-                self.rootnode.used_names = self.used_names
</span></span></span><span style=display:flex;background-color:#3c3d38><span><span style=color:#f92672></span><span style=color:#a6e22e>+        newnode = convert(self.grammar, popnode)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        if self.stack:
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            dfa, state, node = self.stack[-1]
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            assert node[-1] is not None
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            node[-1].append(newnode)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        else:
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            self.rootnode = newnode
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+            self.rootnode.used_names = self.used_names
</span></span></span></code></pre></div><p>Also since <code>blib2to3.pytree.convert</code> is guaranteed to return a non-None value, I could
drop a branch which was neat :)</p><hr><h3 id=detour-lets-build-developer-tooling>Detour: let&rsquo;s build developer tooling!<a hidden class=anchor aria-hidden=true href=#detour-lets-build-developer-tooling>#</a></h3><p>If you&rsquo;ve worked with me before you&rsquo;ll know that I <em>love</em> to write developer tooling to
make life easier. (Un)fortunately this project needed two bits of tooling that simply
didn&rsquo;t exist at the time:</p><ol><li>A benchmark suite</li><li>A tool to compare two builds of Black behaviourally</li></ol><p>The first one is pretty self-explanatory, I needed a good benchmark suite to make sure
this project would actually improve performance, and to also quantify the gains (important
when weighing optimizations).</p><p>The second one is less clear, I effectively wanted <a href=https://github.com/hauntsaninja/mypy_primer target=_blank>mypy-primer</a>, but for Black:</p><p><img loading=lazy src=/media/mypy-primer-comment.png alt="mypy-primer comment on python/mypy PR 12064 describing the impact of the change"></p><blockquote><p><a href=https://github.com/python/mypy/pull/12064 target=_blank>mypy-primer comment on mypy PR #12064</a>.</p></blockquote><p>So I got to work creating <a href=https://github.com/ichard26/blackbench target=_blank>blackbench</a> and
<a href=https://github.com/ichard26/black-mypyc-wheels/blob/c448ae49df7570dc2745eccd947625897f6541ce/diff_shades.py target=_blank>(the original) diff-shades</a>. In hindsight, blackbench sucks and
needs a rewrite so I don&rsquo;t want to go into too much detail about it, but the summary is
that it came with benchmarks for the following tasks:</p><ul><li>Formatting <strong>with</strong> safety checks</li><li>Formatting <strong>without</strong> safety checks</li><li>Blib2to3 parsing</li></ul><p>across quite a few inputs. The story is similar for the original diff-shades, it worked
and made it possible to verify mypyc didn&rsquo;t change formatting, but its code was horrible
(and not to mention unmaintainable). It was bad enough that
<a href=https://github.com/ichard26/diff-shades target=_blank>I rewrote the tool later on</a>.</p><blockquote><p>The TL;DR version of what diff-shades does is that it clones a bunch of projects, runs
Black on &rsquo;em while recording the results. Then you use its other commands to analyze and
compare recordings.</p></blockquote><h3 id=detour-does-gcc-help>Detour: does GCC help?<a hidden class=anchor aria-hidden=true href=#detour-does-gcc-help>#</a></h3><p>At this point I had found a workaround to the GCC
<code>array subscript 1 is above array bounds</code> error and was curious to whether using GCC would
produce faster binaries. The answer turned out to be <a href=https://github.com/ichard26/black-mypyc-wheels/issues/2#issuecomment-896357830 target=_blank><em>very much no</em></a>.</p><blockquote><p>Anyway, other than getting distracted by diff-shades, I looked into the gcc issue to
find a potential workaround. I found one, but it was useless üôÇ Collecting numbers for
both gcc-10 and clang showed that gcc fails in basically all departments:</p><ul><li>takes almost twice as long to compile Black AND definitely uses 200%+ more memory</li><li>had no meaningful difference in generated binary size all while being far more picky
about the C code it&rsquo;s given</li><li>oh and of course produced binaries that were around 8% slower üôÉ</li></ul><p>I&rsquo;m honestly happy that GCC failed to compile on that parser setup code, clang (for
Linux) is so much better.</p></blockquote><hr><h3 id=results>Results<a hidden class=anchor aria-hidden=true href=#results>#</a></h3><blockquote><p><strong>Quick note</strong><br>I also did some micro-optimizations like reordering if checks to hit the
common case first or replacing <code>x = x + 1</code> with <code>x += 1</code>, but to this day I don&rsquo;t know
whether they actually had an impact.</p><p>Additionally, I haven&rsquo;t discussed the last
<a href=https://github.com/psf/black/pull/2431/commits/c7de2eafb5d07033429ab3a18ce02ed093b645c5 target=_blank>optimization round I did for src/black</a>, but there&rsquo;s nothing in that which
I haven&rsquo;t covered yet.</p></blockquote><p>Anyhow, these optimizations bumped the parsing speedup over interpreted from ~1.73x to
~1.9x. You can see the <a href=https://github.com/psf/black/pull/2431/commits/f6a3e788bb8714e41fe0a4cc1ee2058b0a7cb3ac target=_blank>changes made here</a> <a href=https://github.com/psf/black/pull/2431/commits/911d0d8601318fcc04069f2af91a066e499f0db0 target=_blank>and also here</a>.</p><p>For more detail, see the tables at the bottom for the <code>compiled-mypyc-preopt</code> and
<code>compiled-mypyc</code> columns <a href=https://gist.github.com/ichard26/b996ccf410422b44fcd80fb158e05b0d target=_blank>in this report I compiled</a>. It took a long time to
compile this report by the way, setting up a properly configured benchmark setup and
gathering multiple data samples is <em>very</em> time consuming!</p><p>In the end, I managed to increase compiled performance by an additional 10-15% which is
pretty nice! I was aiming for 25%, but in hindsight I might have been hoping for too much
üôÇ. Also yes, they were virtually useless when interpreted.</p><p><strong>We&rsquo;re nearly there, only <a href=../compiling-black-with-mypyc-part-3/>Pt. 3 - Deployment</a>
remains.</strong> It&rsquo;s shorter, believe me.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>In the end, I had to
<a href=https://github.com/psf/black/pull/2431/commits/f5f1099dd9043e7bd62c3fd6d39dee1fd8ba458d target=_blank>revert this optimization so Black wouldn&rsquo;t crash under PyPy</a>, can&rsquo;t
remember what the error was though&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ichard26.github.io/tags/black/>black</a></li><li><a href=https://ichard26.github.io/tags/mypyc/>mypyc</a></li></ul><nav class=paginav><a class=prev href=https://ichard26.github.io/blog/2022/05/compiling-black-with-mypyc-part-3/><span class=title>¬´ Newer</span><br><span>Compiling Black with mypyc, Pt. 3 - Deployment</span></a>
<a class=next href=https://ichard26.github.io/blog/2022/05/compiling-black-with-mypyc-part-1/><span class=title>Older ¬ª</span><br><span>Compiling Black with mypyc, Pt. 1 - Initial Steps</span></a></nav></footer></article></main><footer class=footer><span>¬© 2022-present, Richard Si</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>